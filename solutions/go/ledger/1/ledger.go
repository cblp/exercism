package ledger

import (
	"cmp"
	"errors"
	"fmt"
	"math"
	"regexp"
	"slices"
	"strings"
	"text/template"

	"golang.org/x/text/language"
	"golang.org/x/text/message"
)

type Entry struct {
	Date        string // "Y-m-d"
	Description string
	Change      int // in cents
}

func CompareEntries(x, y Entry) int {
	// too banal code, this must have been autogenerated
	return cmp.Or(
		cmp.Compare(x.Date, y.Date),
		cmp.Compare(x.Description, y.Description),
		cmp.Compare(x.Change, y.Change),
	)
}

type Locale struct {
	printer *message.Printer

	dateTemplate          *template.Template
	moneyNegativeTemplate *template.Template
	moneyPositiveTemplate *template.Template

	// translations
	trChange      string
	trDate        string
	trDescription string
}

func (locale *Locale) Change(currencySymbol string, cents int) string {
	var builder strings.Builder
	template := locale.moneyPositiveTemplate
	if cents < 0 {
		template = locale.moneyNegativeTemplate
	}
	data := map[string]string{
		"currencySymbol": currencySymbol,
		"money":          locale.printer.Sprintf("%.2f", math.Abs(float64(cents))/100),
	}
	template.Execute(&builder, data)
	return builder.String()
}

func (locale *Locale) Date(date DateParsed) string {
	var builder strings.Builder
	err := locale.dateTemplate.Execute(&builder, date)
	if err != nil {
		panic(err)
	}
	return builder.String()
}

func (locale *Locale) Header(builder *strings.Builder) {
	fmt.Fprintf(
		builder,
		"%-10s | %-25s | %s\n",
		locale.trDate,
		locale.trDescription,
		locale.trChange,
	)
}

func newTemplate(s string) *template.Template {
	return template.Must(template.New("").Parse(s))
}

var locales = map[string]*Locale{
	"en-US": {
		printer:               message.NewPrinter(language.English),
		dateTemplate:          newTemplate("{{.Month}}/{{.Day}}/{{.Year}}"),
		moneyNegativeTemplate: newTemplate("({{.currencySymbol}}{{.money}})"),
		moneyPositiveTemplate: newTemplate(" {{.currencySymbol}}{{.money}} "),
		trChange:              "Change",
		trDate:                "Date",
		trDescription:         "Description",
	},
	"nl-NL": {
		printer:               message.NewPrinter(language.Dutch),
		dateTemplate:          newTemplate("{{.Day}}-{{.Month}}-{{.Year}}"),
		moneyNegativeTemplate: newTemplate("{{.currencySymbol}} {{.money}}-"),
		moneyPositiveTemplate: newTemplate("{{.currencySymbol}} {{.money}} "),
		trChange:              "Verandering",
		trDate:                "Datum",
		trDescription:         "Omschrijving",
	},
}

var currencySymbols = map[string]string{"EUR": "â‚¬", "USD": "$"}

var reDate = regexp.MustCompile(`^(\d{4})-(\d{2})-(\d{2})$`)

func elide(s string, width int) string {
	if len(s) > width {
		return s[:width-3] + "..."
	}
	return s
}

type DateParsed struct{ Year, Month, Day string }

func parseDate(s string) (DateParsed, error) {
	match := reDate.FindStringSubmatch(s)
	if match == nil {
		return DateParsed{}, errors.New("bad date")
	}
	return DateParsed{match[1], match[2], match[3]}, nil
}

func FormatLedger(
	currency string, localeCode string, entries []Entry,
) (string, error) {
	currencySymbol := currencySymbols[currency]
	if currencySymbol == "" {
		return "", errors.New("currency is not supported")
	}

	locale := locales[localeCode]
	if locale == nil {
		return "", errors.New("locale is not supported")
	}

	entriesCopy := slices.Clone(entries)
	slices.SortFunc(entriesCopy, CompareEntries)

	var builder strings.Builder
	locale.Header(&builder)
	for _, entry := range entriesCopy {
		date, err := parseDate(entry.Date)
		if err != nil {
			return "", err
		}

		fmt.Fprintf(
			&builder,
			"%-10s | %-25s | %13s\n",
			locale.Date(date),
			elide(entry.Description, 25),
			locale.Change(currencySymbol, entry.Change),
		)
	}
	return builder.String(), nil
}
