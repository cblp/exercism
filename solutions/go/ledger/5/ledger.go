// Changelog:
// * Apply static analysis recommendations
// * Replace duplicate currency switch and fake data with a single currency
//   dictionary and early check
// * Remove parallelism; return early instead of collecting errors
// * Introduce Locale abstraction
// * Abstract date formatting into Locale
// * Abstract change printing into Locale
// * Abstract elision into a function
// * Replace strings.Repeat and rune counting with fmt.Sprintf
// * Use library for sorting instead of ad hoc code
// * Use text/template for some templates (date, change) to make them more
//   readable
// * Use string buffers instead of string concatenation for speed
//   where it doesn't spoil the code

package ledger

import (
	"cmp"
	"errors"
	"fmt"
	"regexp"
	"slices"
	"strings"
	"text/template"
)

type Entry struct {
	Date        string // "Y-m-d"
	Description string
	Change      int // in cents
}

func CompareEntries(x, y Entry) int {
	// too banal code, this must have been autogenerated
	return cmp.Or(
		cmp.Compare(x.Date, y.Date),
		cmp.Compare(x.Description, y.Description),
		cmp.Compare(x.Change, y.Change),
	)
}

type Locale struct {
	decimalPoint          string
	thousandsSep          string
	dateTemplate          *template.Template
	moneyNegativeTemplate *template.Template
	moneyPositiveTemplate *template.Template

	// translations
	trChange      string
	trDate        string
	trDescription string
}

func abs(i int) int {
	if i < 0 {
		return -i
	}
	return i
}

func (locale *Locale) Cents(c int) string {
	var builder strings.Builder
	if c > 100_000 {
		fmt.Fprintf(&builder, "%d%s", c/100_000, locale.thousandsSep)
	}
	fmt.Fprintf(
		&builder, "%d%s%02d", c/100%1000, locale.decimalPoint, c%100,
	)
	return builder.String()
}

func (locale *Locale) Change(currencySymbol string, cents int) string {
	template := locale.moneyPositiveTemplate
	if cents < 0 {
		template = locale.moneyNegativeTemplate
	}
	data := map[string]string{
		"currencySymbol": currencySymbol,
		"amount":         locale.Cents(abs(cents)),
	}
	var builder strings.Builder
	template.Execute(&builder, data)
	return builder.String()
}

func (locale *Locale) Date(date DateParsed) string {
	var builder strings.Builder
	locale.dateTemplate.Execute(&builder, date)
	return builder.String()
}

func t(s string) *template.Template {
	return template.Must(template.New("").Parse(s))
}

var locales = map[string]*Locale{
	"en-US": {
		decimalPoint:          ".",
		thousandsSep:          ",",
		dateTemplate:          t("{{.Month}}/{{.Day}}/{{.Year}}"),
		moneyNegativeTemplate: t("({{.currencySymbol}}{{.amount}})"),
		moneyPositiveTemplate: t(" {{.currencySymbol}}{{.amount}} "),
		trChange:              "Change",
		trDate:                "Date",
		trDescription:         "Description",
	},
	"nl-NL": {
		decimalPoint:          ",",
		thousandsSep:          ".",
		dateTemplate:          t("{{.Day}}-{{.Month}}-{{.Year}}"),
		moneyNegativeTemplate: t("{{.currencySymbol}} {{.amount}}-"),
		moneyPositiveTemplate: t("{{.currencySymbol}} {{.amount}} "),
		trChange:              "Verandering",
		trDate:                "Datum",
		trDescription:         "Omschrijving",
	},
}

var currencySymbols = map[string]string{"EUR": "â‚¬", "USD": "$"}

var reDate = regexp.MustCompile(`^(\d{4})-(\d{2})-(\d{2})$`)

func elide(s string, width int) string {
	if len(s) > width {
		return s[:width-3] + "..."
	}
	return s
}

type DateParsed struct{ Year, Month, Day string }

func parseDate(s string) (DateParsed, error) {
	match := reDate.FindStringSubmatch(s)
	if match == nil {
		return DateParsed{}, errors.New("bad date")
	}
	return DateParsed{match[1], match[2], match[3]}, nil
}

func FormatLedger(
	currency string, localeCode string, entries []Entry,
) (string, error) {
	currencySymbol := currencySymbols[currency]
	if currencySymbol == "" {
		return "", errors.New("currency is not supported")
	}

	locale := locales[localeCode]
	if locale == nil {
		return "", errors.New("locale is not supported")
	}

	entries = slices.SortedFunc(slices.Values(entries), CompareEntries)

	var builder strings.Builder
	fmt.Fprintf(
		&builder,
		"%-10s | %-25s | %s\n",
		locale.trDate,
		locale.trDescription,
		locale.trChange,
	)
	for _, entry := range entries {
		date, err := parseDate(entry.Date)
		if err != nil {
			return "", err
		}

		fmt.Fprintf(
			&builder,
			"%-10s | %-25s | %13s\n",
			locale.Date(date),
			elide(entry.Description, 25),
			locale.Change(currencySymbol, entry.Change),
		)
	}
	return builder.String(), nil
}
